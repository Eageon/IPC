/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2011 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/
#include "AdsCAN.h"
#include <WinDef.h>

//----- (10001000) --------------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  HMODULE *v3; // edx@3
  signed int v4; // esi@3
  int v5; // edi@4
  BOOL result; // eax@5
  int v7; // edi@6

  hInstance = hinstDLL;
  if ( fdwReason )
  {
    if ( fdwReason == 1 )
    {
      word_1000EA3C = 0;
      v3 = &hLibModule;
      v4 = 30;
      do
      {
        v5 = (int)(v3 - 8);
        v3 += 9;
        memset((void *)v5, 0, 0x1Cu);
        *(_WORD *)(v5 + 28) = 0;
        *(v3 - 9) = 0;
        --v4;
      }
      while ( v4 );
    }
    result = 1;
  }
  else
  {
    v7 = 0;
    do
    {
      if ( *(&hLibModule + 9 * (unsigned __int16)v7) )
      {
        FreeLibrary(*(&hLibModule + 9 * (unsigned __int16)v7));
        *(&hLibModule + 9 * (unsigned __int16)v7) = 0;
      }
      ++v7;
    }
    while ( (unsigned __int16)v7 <= word_1000EA3C );
    word_1000EA3C = 0;
    result = 1;
  }
  return result;
}
// 1000EA3C: using guessed type __int16 word_1000EA3C;

//----- (100010A0) --------------------------------------------------------
int __stdcall CANPortOpen(signed __int16 a1, int a2, int a3, int a4)
{
  int result; // eax@2
  int v5; // esi@6
  HMODULE v6; // esi@9
  int v7; // eax@13
  FARPROC v8; // esi@14
  __int16 v9; // cx@17
  unsigned int v10; // eax@17
  int v11; // [sp+10h] [bp-C0h]@0
  HKEY hKey; // [sp+14h] [bp-BCh]@1
  int v13; // [sp+18h] [bp-B8h]@16
  __int16 v14; // [sp+1Ch] [bp-B4h]@17
  DWORD Type; // [sp+20h] [bp-B0h]@1
  DWORD cbData; // [sp+24h] [bp-ACh]@3
  BYTE String1; // [sp+28h] [bp-A8h]@3
  CHAR String2; // [sp+38h] [bp-98h]@1
  CHAR SubKey; // [sp+6Ch] [bp-64h]@1

  Type = 1;
  lstrcpyA(&SubKey, "SYSTEM\\CurrentControlSet\\Services\\ADSDAQ");
  lstrcatA(&SubKey, "\\Device");
  wsprintfA(&String2, "%03d", (unsigned __int16)a1 % 1000);
  lstrcatA(&SubKey, &String2);
  if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE, &SubKey, 0, 0x20019u, &hKey) )
    return 2002;
  cbData = 20;
  if ( RegQueryValueExA(hKey, "DriverName", 0, &Type, &String1, &cbData) )
  {
    RegCloseKey(hKey);
    return 2002;
  }
  RegCloseKey(hKey);
  LOWORD(v11) = word_1000EA3C;
  if ( word_1000EA3C )
  {
    v5 = v11;
    while ( lstrcmpA((LPCSTR)&String1, &byte_1000E5DC[36 * (unsigned __int16)v5]) )
    {
      v5 += 65535;
      if ( !(_WORD)v5 )
        goto LABEL_9;
    }
    v6 = *(&hModule + 9 * (unsigned __int16)v5);
  }
  else
  {
LABEL_9:
    v6 = LoadLibraryA((LPCSTR)&String1);
    if ( (unsigned int)v6 <= 0x20 )
      return ((unsigned __int16)a1 << 12) + 6115;
    if ( (unsigned __int16)word_1000EA3C > 0x1Eu )
      return ((unsigned __int16)a1 << 12) + 6115;
    lstrcpyA(&::String1[36 * (unsigned __int16)word_1000EA3C], (LPCSTR)&String1);
    v7 = (unsigned __int16)word_1000EA3C++;
    *(&hLibModule + 9 * v7) = v6;
  }
  v8 = GetProcAddress(v6, "DriverProc");
  if ( !v8 )
    return ((unsigned __int16)a1 << 12) + 6115;
  result = ((int (__stdcall *)(int, int, _DWORD, _DWORD, int *))v8)(
             dword_1000E1E0,
             dword_1000E1E4,
             0,
             (unsigned __int16)a1,
             &v13);
  if ( !result )
  {
    v9 = v13;
    *(_WORD *)a2 = v13;
    *(_WORD *)a3 = HIWORD(v13);
    *(_WORD *)a4 = v14;
    v10 = 6 * (unsigned __int16)v9;
    dword_1000E564[v10 / 2] = (int)v8;
    dword_1000E560[v10 / 2] = (unsigned __int16)a1;
    word_1000E568[v10] = v9;
    result = 0;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E560: using guessed type int dword_1000E560[];
// 1000E564: using guessed type int dword_1000E564[];
// 1000E568: using guessed type __int16 word_1000E568[];
// 1000EA3C: using guessed type __int16 word_1000EA3C;

//----- (10001300) --------------------------------------------------------
int __stdcall CANPortClose(unsigned __int16 a1)
{
  unsigned int v1; // esi@3
  int v2; // ecx@3
  int result; // eax@4

  if ( a1 && a1 <= 0xAu )
  {
    v1 = 6 * a1;
    v2 = dword_1000E564[3 * a1];
    if ( v2 )
    {
      result = ((int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v2)(dword_1000E1E0, dword_1000E1E4, 1, a1, 0);
      if ( !result )
      {
        dword_1000E564[v1 / 2] = 0;
        dword_1000E560[v1 / 2] = 0;
        word_1000E568[v1] = 0;
      }
    }
    else
    {
      result = 2000;
    }
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E560: using guessed type int dword_1000E560[];
// 1000E564: using guessed type int dword_1000E564[];
// 1000E568: using guessed type __int16 word_1000E568[];

//----- (10001370) --------------------------------------------------------
int __stdcall CANInit(__int16 a1, __int16 a2, __int16 a3, unsigned __int8 a4)
{
  int v4; // eax@3
  int result; // eax@4
  __int16 v6; // [sp+0h] [bp-8h]@5
  __int16 v7; // [sp+2h] [bp-6h]@5
  __int16 v8; // [sp+4h] [bp-4h]@5
  __int16 v9; // [sp+6h] [bp-2h]@5

  if ( a1 && (unsigned __int16)a1 <= 0xAu )
  {
    v4 = dword_1000E564[3 * (unsigned __int16)a1];
    if ( v4 )
    {
      v6 = a1;
      v7 = a2;
      v8 = a3;
      v9 = a4;
      result = ((int (__stdcall *)(int, int, signed int, __int16 *, _DWORD))v4)(
                 dword_1000E1E0,
                 dword_1000E1E4,
                 2,
                 &v6,
                 0);
    }
    else
    {
      result = 2000;
    }
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (100013F0) --------------------------------------------------------
int __stdcall CANReset(unsigned __int16 a1)
{
  int v1; // ecx@3
  int result; // eax@4

  if ( a1 && a1 <= 0xAu )
  {
    v1 = dword_1000E564[3 * a1];
    if ( v1 )
      result = ((int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v1)(dword_1000E1E0, dword_1000E1E4, 5, a1, 0);
    else
      result = 2000;
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001440) --------------------------------------------------------
int __stdcall CANInpb(int a1, __int16 a2, int a3)
{
  int v3; // eax@3
  int result; // eax@4

  if ( (_WORD)a1 && (unsigned __int16)a1 <= 0xAu )
  {
    v3 = dword_1000E564[3 * (unsigned __int16)a1];
    if ( v3 )
    {
      HIWORD(a1) = a2;
      result = ((int (__stdcall *)(int, int, signed int, int *, int))v3)(dword_1000E1E0, dword_1000E1E4, 6, &a1, a3);
    }
    else
    {
      result = 2000;
    }
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (100014B0) --------------------------------------------------------
int __stdcall CANOutpb(__int16 a1, __int16 a2, char a3)
{
  int v3; // eax@3
  int result; // eax@4
  __int16 v5; // [sp+0h] [bp-8h]@5
  __int16 v6; // [sp+2h] [bp-6h]@5
  char v7; // [sp+4h] [bp-4h]@5

  if ( a1 && (unsigned __int16)a1 <= 0xAu )
  {
    v3 = dword_1000E564[3 * (unsigned __int16)a1];
    if ( v3 )
    {
      v5 = a1;
      v7 = a3;
      v6 = a2;
      result = ((int (__stdcall *)(int, int, signed int, __int16 *, _DWORD))v3)(
                 dword_1000E1E0,
                 dword_1000E1E4,
                 7,
                 &v5,
                 0);
    }
    else
    {
      result = 2000;
    }
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001530) --------------------------------------------------------
int __stdcall CANSetBaud(__int16 a1, __int16 a2, __int16 a3)
{
  int v3; // eax@3
  int result; // eax@4
  __int16 v5; // [sp+0h] [bp-8h]@5
  __int16 v6; // [sp+2h] [bp-6h]@5
  __int16 v7; // [sp+4h] [bp-4h]@5

  if ( a1 && (unsigned __int16)a1 <= 0xAu )
  {
    v3 = dword_1000E564[3 * (unsigned __int16)a1];
    if ( v3 )
    {
      v5 = a1;
      v6 = a2;
      v7 = a3;
      result = ((int (__stdcall *)(int, int, signed int, __int16 *, _DWORD))v3)(
                 dword_1000E1E0,
                 dword_1000E1E4,
                 8,
                 &v5,
                 0);
    }
    else
    {
      result = 2000;
    }
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (100015B0) --------------------------------------------------------
int __stdcall CANGetBaudRate(unsigned __int16 a1, int a2)
{
  int v2; // ecx@3
  int result; // eax@4

  if ( a1 && a1 <= 0xAu )
  {
    v2 = dword_1000E564[3 * a1];
    if ( v2 )
      result = ((int (__stdcall *)(int, int, signed int, _DWORD, int))v2)(dword_1000E1E0, dword_1000E1E4, 9, a1, a2);
    else
      result = 2000;
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001600) --------------------------------------------------------
int __stdcall CANSetAcp(__int16 a1, __int16 a2, __int16 a3)
{
  int v3; // eax@3
  int result; // eax@4
  __int16 v5; // [sp+0h] [bp-8h]@5
  __int16 v6; // [sp+2h] [bp-6h]@5
  __int16 v7; // [sp+4h] [bp-4h]@5

  if ( a1 && (unsigned __int16)a1 <= 0xAu )
  {
    v3 = dword_1000E564[3 * (unsigned __int16)a1];
    if ( v3 )
    {
      v5 = a1;
      v7 = a3;
      v6 = a2;
      result = ((int (__stdcall *)(int, int, signed int, __int16 *, _DWORD))v3)(
                 dword_1000E1E0,
                 dword_1000E1E4,
                 10,
                 &v5,
                 0);
    }
    else
    {
      result = 2000;
    }
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001680) --------------------------------------------------------
int __stdcall CANSetAcpEx(unsigned __int16 a1, int a2)
{
  int v2; // ecx@3
  int result; // eax@4

  if ( a1 && a1 <= 0xAu )
  {
    v2 = dword_1000E564[3 * a1];
    if ( v2 )
      result = ((int (__stdcall *)(int, int, signed int, _DWORD, int))v2)(dword_1000E1E0, dword_1000E1E4, 11, a1, a2);
    else
      result = 2000;
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (100016D0) --------------------------------------------------------
int __stdcall CANSetIntrMaskEx(unsigned __int16 a1, unsigned __int8 a2)
{
  int v2; // ecx@3
  int result; // eax@4

  if ( a1 && a1 <= 0xAu )
  {
    v2 = dword_1000E564[3 * a1];
    if ( v2 )
      result = ((int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v2)(
                 dword_1000E1E0,
                 dword_1000E1E4,
                 12,
                 a1,
                 a2);
    else
      result = 2000;
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001730) --------------------------------------------------------
int __stdcall CANSetOutCtrl(unsigned __int16 a1, unsigned __int16 a2)
{
  int v2; // ecx@3
  int result; // eax@4

  if ( a1 && a1 <= 0xAu )
  {
    v2 = dword_1000E564[3 * a1];
    if ( v2 )
      result = ((int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v2)(
                 dword_1000E1E0,
                 dword_1000E1E4,
                 13,
                 a1,
                 a2);
    else
      result = 2000;
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001790) --------------------------------------------------------
int __stdcall CANSetNormal(unsigned __int16 a1)
{
  int v1; // ecx@3
  int result; // eax@4

  if ( a1 && a1 <= 0xAu )
  {
    v1 = dword_1000E564[3 * a1];
    if ( v1 )
      result = ((int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v1)(
                 dword_1000E1E0,
                 dword_1000E1E4,
                 14,
                 a1,
                 0);
    else
      result = 2000;
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (100017E0) --------------------------------------------------------
int __stdcall CANHwReset(unsigned __int16 a1)
{
  int v1; // ecx@3
  int result; // eax@4

  if ( a1 && a1 <= 0xAu )
  {
    v1 = dword_1000E564[3 * a1];
    if ( v1 )
      result = ((int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v1)(dword_1000E1E0, dword_1000E1E4, 4, a1, 0);
    else
      result = 2000;
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001830) --------------------------------------------------------
int __stdcall CANSendMsg(__int16 a1, int a2, int a3)
{
  int v3; // eax@3
  int result; // eax@4
  __int16 v5; // [sp+0h] [bp-Ch]@5
  int v6; // [sp+4h] [bp-8h]@5
  int v7; // [sp+8h] [bp-4h]@5

  if ( a1 && (unsigned __int16)a1 <= 0xAu )
  {
    v3 = dword_1000E564[3 * (unsigned __int16)a1];
    if ( v3 )
    {
      v5 = a1;
      v7 = a3;
      v6 = a2;
      result = ((int (__stdcall *)(int, int, signed int, __int16 *, _DWORD))v3)(
                 dword_1000E1E0,
                 dword_1000E1E4,
                 15,
                 &v5,
                 0);
    }
    else
    {
      result = 2000;
    }
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (100018B0) --------------------------------------------------------
int __stdcall CANQueryMsg(unsigned __int16 a1, int a2, int a3)
{
  int v3; // ecx@3
  int result; // eax@4
  int v5; // [sp+0h] [bp-8h]@5
  int v6; // [sp+4h] [bp-4h]@5

  if ( a1 && a1 <= 0xAu )
  {
    v3 = dword_1000E564[3 * a1];
    if ( v3 )
    {
      v5 = a2;
      v6 = a3;
      result = ((int (__stdcall *)(int, int, signed int, _DWORD, int *))v3)(dword_1000E1E0, dword_1000E1E4, 16, a1, &v5);
    }
    else
    {
      result = 2000;
    }
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001920) --------------------------------------------------------
int __stdcall CANWaitForMsg(__int16 a1, int a2, int a3)
{
  int v3; // eax@3
  int result; // eax@4
  __int16 v5; // [sp+0h] [bp-8h]@5
  int v6; // [sp+4h] [bp-4h]@5

  if ( a1 && (unsigned __int16)a1 <= 0xAu )
  {
    v3 = dword_1000E564[3 * (unsigned __int16)a1];
    if ( v3 )
    {
      v5 = a1;
      v6 = a3;
      result = ((int (__stdcall *)(int, int, signed int, __int16 *, int))v3)(
                 dword_1000E1E0,
                 dword_1000E1E4,
                 17,
                 &v5,
                 a2);
    }
    else
    {
      result = 2000;
    }
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001990) --------------------------------------------------------
int __stdcall CANWaitForFIFOEvent(__int16 a1, int a2, int a3)
{
  int v3; // eax@3
  int result; // eax@4
  __int16 v5; // [sp+0h] [bp-8h]@5
  int v6; // [sp+4h] [bp-4h]@5

  if ( a1 && (unsigned __int16)a1 <= 0xAu )
  {
    v3 = dword_1000E564[3 * (unsigned __int16)a1];
    if ( v3 )
    {
      v5 = a1;
      v6 = a2;
      result = ((int (__stdcall *)(int, int, signed int, __int16 *, int))v3)(
                 dword_1000E1E0,
                 dword_1000E1E4,
                 18,
                 &v5,
                 a3);
    }
    else
    {
      result = 2000;
    }
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001A00) --------------------------------------------------------
int __stdcall CANQueryID(unsigned __int16 a1, int a2, int a3)
{
  int v3; // ecx@3
  int result; // eax@4
  int v5; // [sp+0h] [bp-8h]@5
  int v6; // [sp+4h] [bp-4h]@5

  if ( a1 && a1 <= 0xAu )
  {
    v3 = dword_1000E564[3 * a1];
    if ( v3 )
    {
      v6 = a3;
      v5 = a2;
      result = ((int (__stdcall *)(int, int, signed int, _DWORD, int *))v3)(dword_1000E1E0, dword_1000E1E4, 19, a1, &v5);
    }
    else
    {
      result = 2000;
    }
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001A70) --------------------------------------------------------
int __stdcall CANWaitForID(__int16 a1, int a2, int a3)
{
  int v3; // eax@3
  int result; // eax@4
  __int16 v5; // [sp+0h] [bp-8h]@5
  int v6; // [sp+4h] [bp-4h]@5

  if ( a1 && (unsigned __int16)a1 <= 0xAu )
  {
    v3 = dword_1000E564[3 * (unsigned __int16)a1];
    if ( v3 )
    {
      v5 = a1;
      v6 = a3;
      result = ((int (__stdcall *)(int, int, signed int, __int16 *, int))v3)(
                 dword_1000E1E0,
                 dword_1000E1E4,
                 20,
                 &v5,
                 a2);
    }
    else
    {
      result = 2000;
    }
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001AE0) --------------------------------------------------------
int __stdcall CANEnableMessaging(__int16 a1, __int16 a2, int a3, int a4, int a5)
{
  int v5; // eax@3
  int result; // eax@4
  __int16 v7; // [sp+0h] [bp-10h]@5
  __int16 v8; // [sp+2h] [bp-Eh]@5
  int v9; // [sp+4h] [bp-Ch]@5
  int v10; // [sp+8h] [bp-8h]@5
  int v11; // [sp+Ch] [bp-4h]@5

  if ( a1 && (unsigned __int16)a1 <= 0xAu )
  {
    v5 = dword_1000E564[3 * (unsigned __int16)a1];
    if ( v5 )
    {
      v7 = a1;
      v10 = a4;
      v11 = a5;
      v9 = a3;
      v8 = a2;
      result = ((int (__stdcall *)(int, int, signed int, __int16 *, _DWORD))v5)(
                 dword_1000E1E0,
                 dword_1000E1E4,
                 21,
                 &v7,
                 0);
    }
    else
    {
      result = 2000;
    }
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001B70) --------------------------------------------------------
int __stdcall CANGetEventName(unsigned __int16 a1, int a2)
{
  int v2; // ecx@3
  int result; // eax@4

  if ( a1 && a1 <= 0xAu )
  {
    v2 = dword_1000E564[3 * a1];
    if ( v2 )
      result = ((int (__stdcall *)(int, int, signed int, _DWORD, int))v2)(dword_1000E1E0, dword_1000E1E4, 22, a1, a2);
    else
      result = 2000;
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001BC0) --------------------------------------------------------
int __stdcall CANEnableEvent(unsigned __int16 a1, int a2)
{
  int v2; // ecx@3
  int result; // eax@4

  if ( a1 && a1 <= 0xAu )
  {
    v2 = dword_1000E564[3 * a1];
    if ( v2 )
      result = ((int (__stdcall *)(int, int, signed int, _DWORD, int))v2)(dword_1000E1E0, dword_1000E1E4, 23, a1, a2);
    else
      result = 2000;
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001C10) --------------------------------------------------------
int __stdcall CANCheckEvent(unsigned __int16 a1, int a2)
{
  int v2; // ecx@3
  int result; // eax@4

  if ( a1 && a1 <= 0xAu )
  {
    v2 = dword_1000E564[3 * a1];
    if ( v2 )
      result = ((int (__stdcall *)(int, int, signed int, _DWORD, int))v2)(dword_1000E1E0, dword_1000E1E4, 24, a1, a2);
    else
      result = 2000;
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001C60) --------------------------------------------------------
int __stdcall CANReadFile(__int16 a1, int a2, int a3, int a4)
{
  int v4; // eax@3
  int result; // eax@4
  int v6; // [sp+0h] [bp-10h]@5
  int v7; // [sp+4h] [bp-Ch]@5
  __int16 v8; // [sp+8h] [bp-8h]@5
  int v9; // [sp+Ch] [bp-4h]@5

  if ( a1 && (unsigned __int16)a1 <= 0xAu )
  {
    v4 = dword_1000E564[3 * (unsigned __int16)a1];
    if ( v4 )
    {
      v8 = a1;
      v6 = a3;
      v9 = a2;
      v7 = a4;
      result = ((int (__stdcall *)(int, int, signed int, __int16 *, int *))v4)(
                 dword_1000E1E0,
                 dword_1000E1E4,
                 25,
                 &v8,
                 &v6);
    }
    else
    {
      result = 2000;
    }
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001CE0) --------------------------------------------------------
int __stdcall CANWriteFile(__int16 a1, int a2, int a3)
{
  int v3; // eax@3
  int result; // eax@4
  __int16 v5; // [sp+0h] [bp-8h]@5
  int v6; // [sp+4h] [bp-4h]@5

  if ( a1 && (unsigned __int16)a1 <= 0xAu )
  {
    v3 = dword_1000E564[3 * (unsigned __int16)a1];
    if ( v3 )
    {
      v5 = a1;
      v6 = a3;
      result = ((int (__stdcall *)(int, int, signed int, __int16 *, int))v3)(
                 dword_1000E1E0,
                 dword_1000E1E4,
                 26,
                 &v5,
                 a2);
    }
    else
    {
      result = 2000;
    }
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001D50) --------------------------------------------------------
int __stdcall CANSetBufferPtr(__int16 a1, int a2, int a3, int a4)
{
  int v4; // eax@3
  int result; // eax@4
  __int16 v6; // [sp+0h] [bp-Ch]@5
  int v7; // [sp+4h] [bp-8h]@5
  int v8; // [sp+8h] [bp-4h]@5

  if ( a1 && (unsigned __int16)a1 <= 0xAu )
  {
    v4 = dword_1000E564[3 * (unsigned __int16)a1];
    if ( v4 )
    {
      v6 = a1;
      v7 = a2;
      v8 = a3;
      result = ((int (__stdcall *)(int, int, signed int, __int16 *, int))v4)(
                 dword_1000E1E0,
                 dword_1000E1E4,
                 28,
                 &v6,
                 a4);
    }
    else
    {
      result = 2000;
    }
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001DD0) --------------------------------------------------------
int __stdcall CANSetCountPtr(__int16 a1, int a2, int a3)
{
  int v3; // eax@3
  int result; // eax@4
  __int16 v5; // [sp+0h] [bp-8h]@5
  int v6; // [sp+4h] [bp-4h]@5

  if ( a1 && (unsigned __int16)a1 <= 0xAu )
  {
    v3 = dword_1000E564[3 * (unsigned __int16)a1];
    if ( v3 )
    {
      v5 = a1;
      v6 = a2;
      result = ((int (__stdcall *)(int, int, signed int, __int16 *, int))v3)(
                 dword_1000E1E0,
                 dword_1000E1E4,
                 29,
                 &v5,
                 a3);
    }
    else
    {
      result = 2000;
    }
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001E40) --------------------------------------------------------
int __stdcall CANEnableRxInt(unsigned __int16 a1)
{
  int v1; // ecx@3
  int result; // eax@4

  if ( a1 && a1 <= 0xAu )
  {
    v1 = dword_1000E564[3 * a1];
    if ( v1 )
      result = ((int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v1)(
                 dword_1000E1E0,
                 dword_1000E1E4,
                 27,
                 a1,
                 0);
    else
      result = 2000;
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001E90) --------------------------------------------------------
int __stdcall CANGetProtocolType(unsigned __int16 a1, int a2)
{
  int v2; // ecx@3
  int result; // eax@4

  if ( a1 && a1 <= 0xAu )
  {
    v2 = dword_1000E564[3 * a1];
    if ( v2 )
      result = ((int (__stdcall *)(int, int, signed int, _DWORD, int))v2)(dword_1000E1E0, dword_1000E1E4, 30, a1, a2);
    else
      result = 2000;
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001EE0) --------------------------------------------------------
int __stdcall CANSetProtocolType(int a1, __int16 a2)
{
  int v2; // eax@3
  int result; // eax@4

  if ( (_WORD)a1 && (unsigned __int16)a1 <= 0xAu )
  {
    v2 = dword_1000E564[3 * (unsigned __int16)a1];
    if ( v2 )
    {
      HIWORD(a1) = a2;
      result = ((int (__stdcall *)(int, int, signed int, int *, _DWORD))v2)(dword_1000E1E0, dword_1000E1E4, 3, &a1, 0);
    }
    else
    {
      result = 2000;
    }
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001F40) --------------------------------------------------------
int __stdcall CANGetControllerErrorCodeEx(unsigned __int16 a1, int a2)
{
  int v2; // ecx@3
  int result; // eax@4

  if ( a1 && a1 <= 0xAu )
  {
    v2 = dword_1000E564[3 * a1];
    if ( v2 )
      result = ((int (__stdcall *)(int, int, signed int, _DWORD, int))v2)(dword_1000E1E0, dword_1000E1E4, 31, a1, a2);
    else
      result = 2000;
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001F90) --------------------------------------------------------
int __stdcall CANGetArbitrationLostCatchMsgEx(unsigned __int16 a1, int a2)
{
  int v2; // ecx@3
  int result; // eax@4

  if ( a1 && a1 <= 0xAu )
  {
    v2 = dword_1000E564[3 * a1];
    if ( v2 )
      result = ((int (__stdcall *)(int, int, signed int, _DWORD, int))v2)(dword_1000E1E0, dword_1000E1E4, 32, a1, a2);
    else
      result = 2000;
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (10001FE0) --------------------------------------------------------
signed int __stdcall CANGetErrorMessage(signed int a1, void *a2)
{
  signed int result; // eax@2

  if ( !a2 )
    return 2009;
  if ( a1 > 2009 )
  {
    switch ( a1 )
    {
      case 2010:
        memcpy(a2, "No data in CAN controller receive buffer.", 0x2Au);
        result = 0;
        break;
      case 2011:
        memcpy(a2, "CAN Bus is closed, because too more errors occured.", 0x34u);
        result = 0;
        break;
      case 2012:
        memcpy(a2, "Open notification event is unsuccessful.", 0x29u);
        result = 0;
        break;
      case 2013:
        memcpy(a2, "DLL can not create device object, please setup hardware.", 0x39u);
        result = 0;
        break;
      case 2014:
        memcpy(a2, "Port is opened already, must be closed first or needn't to open.", 0x41u);
        result = 0;
        break;
      case 2015:
        memcpy(a2, "Specified port's registry information is incorrect or not exists.", 0x42u);
        result = 0;
        break;
      case 2016:
        memcpy(a2, "Maping memory of hardware register is unsuccessful.", 0x34u);
        result = 0;
        break;
      case 2017:
        memcpy(a2, "Port is not initialized, must call CANInit/CanInitEx.", 0x36u);
        result = 0;
        break;
      case 2018:
        memcpy(a2, "Port is initialized already, current operation cannot completed.", 0x41u);
        result = 0;
        break;
      case 2019:
        memcpy(a2, "Can not Setup specified Port.", 0x1Eu);
        result = 0;
        break;
      default:
        goto LABEL_36;
    }
  }
  else
  {
    if ( a1 == 2009 )
    {
      memcpy(a2, "Speified parameter is incorrect.", 0x21u);
      result = 0;
    }
    else
    {
      if ( a1 > 2004 )
      {
        switch ( a1 )
        {
          case 2005:
            memcpy(a2, "CAN Controller is in work mode, please set controller to reset mode.", 0x45u);
            result = 0;
            break;
          case 2006:
            memcpy(a2, "Specified data length is incorrect, must from 0 to 8.", 0x36u);
            result = 0;
            break;
          case 2007:
            memcpy(a2, "Serious Can Bus Error occured.", 0x1Fu);
            result = 0;
            break;
          case 2008:
            memcpy(a2, "Operation is time out.", 0x17u);
            result = 0;
            break;
          default:
            goto LABEL_36;
        }
      }
      else
      {
        if ( a1 == 2004 )
        {
          memcpy(a2, "CAN Controller is in reset mode, please set controller to work mode.", 0x45u);
          result = 0;
        }
        else
        {
          if ( a1 > 2001 )
          {
            if ( a1 == 2002 )
            {
              memcpy(a2, "Port Index is invalid, must from 1 to 10.", 0x2Au);
              return 0;
            }
            if ( a1 == 2003 )
            {
              memcpy(a2, "Function can not work correct when Port is opened with another PROTOCOL.", 0x49u);
              return 0;
            }
          }
          else
          {
            if ( a1 == 2001 )
            {
              memcpy(a2, "Specified frame format specified is incorrect.", 0x2Fu);
              return 0;
            }
            if ( !a1 )
            {
              memcpy(a2, "Operation is successful.", 0x19u);
              return 0;
            }
            if ( a1 == 2000 )
            {
              memcpy(a2, "Port is not Opened.", 0x14u);
              return 0;
            }
          }
LABEL_36:
          memcpy(a2, "Invalid Error Code!!!", 0x16u);
          result = 0;
        }
      }
    }
  }
  return result;
}

//----- (10002270) --------------------------------------------------------
int __stdcall CANWakeUpEx(unsigned __int16 a1, int a2)
{
  int v2; // ecx@3
  int result; // eax@4

  if ( a1 && a1 <= 0xAu )
  {
    v2 = dword_1000E564[3 * a1];
    if ( v2 )
      result = ((int (__stdcall *)(int, int, signed int, _DWORD, int))v2)(dword_1000E1E0, dword_1000E1E4, 34, a1, a2);
    else
      result = 2000;
  }
  else
  {
    result = 2002;
  }
  return result;
}
// 1000E1E0: using guessed type int dword_1000E1E0;
// 1000E1E4: using guessed type int dword_1000E1E4;
// 1000E564: using guessed type int dword_1000E564[];

//----- (100022C0) --------------------------------------------------------
signed int __stdcall CANSelectDevice(HWND hWndParent, int a2, unsigned __int32 *a3, char *a4)
{
  unsigned __int32 v4; // eax@1
  signed int result; // eax@2

  v4 = *a3;
  dword_1000E544 = a4;
  Value = v4;
  dword_1000EA38 = a2;
  if ( DialogBoxParamA(hInstance, (LPCSTR)0x83, hWndParent, (DLGPROC)DialogFunc, 0) )
  {
    result = 1;
  }
  else
  {
    result = 0;
    *a3 = Value;
  }
  return result;
}
// 1000EA38: using guessed type int dword_1000EA38;

//----- (10002320) --------------------------------------------------------
signed int __cdecl sub_10002320(unsigned __int32 Value, unsigned int a2, void *a3)
{
  signed int result; // eax@2
  unsigned int v4; // edx@3
  int v5; // edi@5
  int i; // ecx@5
  signed int j; // eax@8
  char v8; // bl@9
  int v9; // ecx@9

  if ( (signed int)a2 <= 9 )
  {
    _ultoa(Value, &Dest, 10);
    result = 0;
    v4 = strlen(&Dest);
    if ( (signed int)v4 <= (signed int)a2 )
    {
      if ( (signed int)a2 > 0 )
      {
        memset(a3, 808464432, 4 * (a2 >> 2));
        v5 = (int)((char *)a3 + 4 * (a2 >> 2));
        for ( i = a2 & 3; i; --i )
          *(_BYTE *)v5++ = 48;
      }
      for ( j = 0; j <= (signed int)v4; *((_BYTE *)a3 + v9) = v8 )
      {
        v8 = *(&Dest + j);
        v9 = a2 + j++ - v4;
      }
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100023B0) --------------------------------------------------------
int __stdcall CANGetAddress(int a1)
{
  return a1;
}

//----- (100023C0) --------------------------------------------------------
signed int __cdecl DialogFunc(HWND hWnd, int a2, __int16 a3, int a4)
{
  BYTE *v5; // edi@9
  signed int v6; // ecx@9
  bool v7; // zf@11
  signed int v8; // ecx@12
  const void *v9; // esi@12
  char *v10; // edi@12
  unsigned int v11; // edx@12
  signed int v12; // ecx@12
  int v13; // edi@15
  int v14; // esi@16
  int v15; // edi@16
  BYTE *v16; // edi@16
  signed int v17; // ecx@16
  signed int v18; // ecx@19
  const void *v19; // esi@19
  char *v20; // edi@19
  unsigned int v21; // edx@19
  signed int v22; // ecx@19
  signed int v23; // ecx@23
  signed int v24; // ecx@26
  const void *v25; // esi@26
  char *v26; // edi@26
  unsigned int v27; // edx@26
  signed int v28; // ecx@26
  unsigned __int32 v29; // edx@32
  BYTE Data; // [sp+0h] [bp-34h]@9

  if ( a2 == 78 )
  {
    if ( *(_DWORD *)(a4 + 8) == -402 )
    {
      v29 = *(_DWORD *)(a4 + 92);
      *(_DWORD *)(a4 + 56) = 5;
      Value = v29;
    }
    return 1;
  }
  if ( a2 == 272 )
  {
    InitCommonControls();
    sub_10002820(hWnd);
    return 1;
  }
  if ( a2 != 273 )
    return 0;
  if ( a3 != 1 )
  {
    if ( a3 == 2 )
    {
      EndDialog(hWnd, 0);
      return 1;
    }
    return 1;
  }
  if ( Value >= 0xF4240 )
  {
    Value -= 1000000;
    v14 = (signed int)Value / 1000;
    v15 = (signed int)Value % 1000;
    sub_100026A0((signed int)Value % 1000, (signed int)Value / 1000, "DeviceName", &Data, 0x32u);
    sprintf(dword_1000E544, " %03d%03d : <", v14, v15);
    v16 = &Data;
    v17 = -1;
    do
    {
      if ( !v17 )
        break;
      v7 = *v16++ == 0;
      --v17;
    }
    while ( !v7 );
    v18 = ~v17;
    v19 = &v16[-v18];
    v20 = dword_1000E544;
    v21 = v18;
    v22 = -1;
    do
    {
      if ( !v22 )
        break;
      v7 = *v20++ == 0;
      --v22;
    }
    while ( !v7 );
    memcpy(v20 - 1, v19, v21);
    v13 = (int)">";
  }
  else
  {
    sub_10002590(Value, "DeviceName", &Data, 0x32u);
    sprintf(dword_1000E544, " %03d : {", Value);
    v5 = &Data;
    v6 = -1;
    do
    {
      if ( !v6 )
        break;
      v7 = *v5++ == 0;
      --v6;
    }
    while ( !v7 );
    v8 = ~v6;
    v9 = &v5[-v8];
    v10 = dword_1000E544;
    v11 = v8;
    v12 = -1;
    do
    {
      if ( !v12 )
        break;
      v7 = *v10++ == 0;
      --v12;
    }
    while ( !v7 );
    memcpy(v10 - 1, v9, v11);
    v13 = (int)"}";
  }
  v23 = -1;
  do
  {
    if ( !v23 )
      break;
    v7 = *(_BYTE *)v13++ == 0;
    --v23;
  }
  while ( !v7 );
  v24 = ~v23;
  v25 = (const void *)(v13 - v24);
  v26 = dword_1000E544;
  v27 = v24;
  v28 = -1;
  do
  {
    if ( !v28 )
      break;
    v7 = *v26++ == 0;
    --v28;
  }
  while ( !v7 );
  memcpy(v26 - 1, v25, v27);
  EndDialog(hWnd, 0);
  return 1;
}

//----- (10002590) --------------------------------------------------------
signed int __cdecl sub_10002590(unsigned __int32 Value, LPCSTR lpValueName, LPBYTE lpData, DWORD cbData)
{
  int v4; // edi@1
  signed int v5; // ecx@1
  bool v6; // zf@3
  signed int v7; // ecx@4
  const void *v8; // esi@4
  unsigned int v9; // ebx@4
  const CHAR *v10; // edi@4
  signed int v11; // ecx@4
  int *v12; // edi@7
  signed int v13; // ecx@7
  signed int v14; // ecx@10
  const void *v15; // esi@10
  unsigned int v16; // ebx@10
  const CHAR *v17; // edi@10
  signed int v18; // ecx@10
  signed int result; // eax@14
  HKEY hKey; // [sp+Ch] [bp-B4h]@13
  DWORD Type; // [sp+10h] [bp-B0h]@15
  int v22; // [sp+14h] [bp-ACh]@1
  const CHAR SubKey; // [sp+48h] [bp-78h]@1
  char v24; // [sp+70h] [bp-50h]@1

  sub_10002320(Value, 3u, &v22);
  memcpy((void *)&SubKey, "SYSTEM\\CurrentControlSet\\Services\\ADSDAQ", 0x28u);
  v24 = ::SubKey[40];
  v4 = (int)"\\Device";
  v5 = -1;
  do
  {
    if ( !v5 )
      break;
    v6 = *(_BYTE *)v4++ == 0;
    --v5;
  }
  while ( !v6 );
  v7 = ~v5;
  v8 = (const void *)(v4 - v7);
  v9 = v7;
  v10 = &SubKey;
  v11 = -1;
  do
  {
    if ( !v11 )
      break;
    v6 = *v10++ == 0;
    --v11;
  }
  while ( !v6 );
  memcpy((void *)(v10 - 1), v8, v9);
  v12 = &v22;
  v13 = -1;
  do
  {
    if ( !v13 )
      break;
    v6 = *(_BYTE *)v12 == 0;
    v12 = (int *)((char *)v12 + 1);
    --v13;
  }
  while ( !v6 );
  v14 = ~v13;
  v15 = (char *)v12 - v14;
  v16 = v14;
  v17 = &SubKey;
  v18 = -1;
  do
  {
    if ( !v18 )
      break;
    v6 = *v17++ == 0;
    --v18;
  }
  while ( !v6 );
  memcpy((void *)(v17 - 1), v15, v16);
  if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE, &SubKey, 0, 0x20019u, &hKey) )
  {
    result = 0;
  }
  else
  {
    if ( RegQueryValueExA(hKey, lpValueName, 0, &Type, lpData, &cbData) )
    {
      RegCloseKey(hKey);
      result = 0;
    }
    else
    {
      RegCloseKey(hKey);
      result = 1;
    }
  }
  return result;
}

//----- (100026A0) --------------------------------------------------------
signed int __cdecl sub_100026A0(unsigned __int32 Value, unsigned __int32 a2, LPCSTR lpValueName, LPBYTE lpData, DWORD cbData)
{
  int v5; // edi@1
  signed int v6; // ecx@1
  bool v7; // zf@3
  signed int v8; // ecx@4
  const void *v9; // esi@4
  unsigned int v10; // ebx@4
  const CHAR *v11; // edi@4
  signed int v12; // ecx@4
  int *v13; // edi@7
  signed int v14; // ecx@7
  signed int v15; // ecx@10
  const void *v16; // esi@10
  unsigned int v17; // ebx@10
  const CHAR *v18; // edi@10
  signed int v19; // ecx@10
  int v20; // edi@13
  signed int v21; // ecx@13
  signed int v22; // ecx@16
  const void *v23; // esi@16
  unsigned int v24; // ebx@16
  const CHAR *v25; // edi@16
  signed int v26; // ecx@16
  int *v27; // edi@19
  signed int v28; // ecx@19
  signed int v29; // ecx@22
  const void *v30; // esi@22
  unsigned int v31; // ebx@22
  const CHAR *v32; // edi@22
  signed int v33; // ecx@22
  signed int result; // eax@26
  HKEY hKey; // [sp+Ch] [bp-B4h]@25
  DWORD Type; // [sp+10h] [bp-B0h]@27
  int v37; // [sp+14h] [bp-ACh]@7
  const CHAR SubKey; // [sp+48h] [bp-78h]@1
  char v39; // [sp+70h] [bp-50h]@1

  memcpy((void *)&SubKey, "SYSTEM\\CurrentControlSet\\Services\\ADSDAQ", 0x28u);
  v39 = ::SubKey[40];
  v5 = (int)"\\Device";
  v6 = -1;
  do
  {
    if ( !v6 )
      break;
    v7 = *(_BYTE *)v5++ == 0;
    --v6;
  }
  while ( !v7 );
  v8 = ~v6;
  v9 = (const void *)(v5 - v8);
  v10 = v8;
  v11 = &SubKey;
  v12 = -1;
  do
  {
    if ( !v12 )
      break;
    v7 = *v11++ == 0;
    --v12;
  }
  while ( !v7 );
  memcpy((void *)(v11 - 1), v9, v10);
  sub_10002320(Value, 3u, &v37);
  v13 = &v37;
  v14 = -1;
  do
  {
    if ( !v14 )
      break;
    v7 = *(_BYTE *)v13 == 0;
    v13 = (int *)((char *)v13 + 1);
    --v14;
  }
  while ( !v7 );
  v15 = ~v14;
  v16 = (char *)v13 - v15;
  v17 = v15;
  v18 = &SubKey;
  v19 = -1;
  do
  {
    if ( !v19 )
      break;
    v7 = *v18++ == 0;
    --v19;
  }
  while ( !v7 );
  memcpy((void *)(v18 - 1), v16, v17);
  v20 = (int)"\\Module";
  v21 = -1;
  do
  {
    if ( !v21 )
      break;
    v7 = *(_BYTE *)v20++ == 0;
    --v21;
  }
  while ( !v7 );
  v22 = ~v21;
  v23 = (const void *)(v20 - v22);
  v24 = v22;
  v25 = &SubKey;
  v26 = -1;
  do
  {
    if ( !v26 )
      break;
    v7 = *v25++ == 0;
    --v26;
  }
  while ( !v7 );
  memcpy((void *)(v25 - 1), v23, v24);
  sub_10002320(a2, 3u, &v37);
  v27 = &v37;
  v28 = -1;
  do
  {
    if ( !v28 )
      break;
    v7 = *(_BYTE *)v27 == 0;
    v27 = (int *)((char *)v27 + 1);
    --v28;
  }
  while ( !v7 );
  v29 = ~v28;
  v30 = (char *)v27 - v29;
  v31 = v29;
  v32 = &SubKey;
  v33 = -1;
  do
  {
    if ( !v33 )
      break;
    v7 = *v32++ == 0;
    --v33;
  }
  while ( !v7 );
  memcpy((void *)(v32 - 1), v30, v31);
  if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE, &SubKey, 0, 0x20019u, &hKey) )
  {
    result = 0;
  }
  else
  {
    if ( RegQueryValueExA(hKey, lpValueName, 0, &Type, lpData, &cbData) )
    {
      RegCloseKey(hKey);
      result = 0;
    }
    else
    {
      RegCloseKey(hKey);
      result = 1;
    }
  }
  return result;
}

//----- (10002820) --------------------------------------------------------
signed int __cdecl sub_10002820(HWND hWnd)
{
  HWND v1; // ebx@1
  signed int result; // eax@2
  int v3; // ebp@7
  BYTE *v4; // edi@8
  signed int v5; // ecx@8
  bool v6; // zf@10
  signed int v7; // ecx@11
  const void *v8; // esi@11
  const CHAR *v9; // edi@11
  unsigned int v10; // edx@11
  signed int v11; // ecx@11
  int v12; // edi@14
  signed int v13; // ecx@14
  signed int v14; // ecx@17
  const void *v15; // esi@17
  const CHAR *v16; // edi@17
  unsigned int v17; // edx@17
  signed int v18; // ecx@17
  void *v19; // edi@20
  LPARAM v20; // eax@20
  LPARAM v21; // edx@20
  LPARAM v22; // eax@26
  DWORD dwIndex; // [sp+10h] [bp-104h]@3
  HKEY hKey; // [sp+14h] [bp-100h]@1
  LPARAM v25; // [sp+18h] [bp-FCh]@1
  LPARAM v26; // [sp+1Ch] [bp-F8h]@20
  DWORD cchName; // [sp+20h] [bp-F4h]@4
  LPARAM lParam; // [sp+24h] [bp-F0h]@1
  int v29; // [sp+28h] [bp-ECh]@1
  int v30; // [sp+2Ch] [bp-E8h]@1
  const CHAR *v31; // [sp+3Ch] [bp-D8h]@1
  int v32; // [sp+40h] [bp-D4h]@20
  int v33; // [sp+50h] [bp-C4h]@1
  struct _FILETIME ftLastWriteTime; // [sp+58h] [bp-BCh]@4
  const CHAR Name; // [sp+60h] [bp-B4h]@2
  char v36; // [sp+61h] [bp-B3h]@6
  char Str; // [sp+66h] [bp-AEh]@7
  BYTE Data; // [sp+E0h] [bp-34h]@7

  v1 = GetDlgItem(hWnd, 1000);
  lParam = -65536;
  v29 = -65534;
  v30 = 5;
  v31 = "ADSDAQ";
  v33 = 0;
  v25 = SendMessageA(v1, 0x1100u, 0, (LPARAM)&lParam);
  if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Services\\ADSDAQ", 0, 0x20019u, &hKey) )
  {
    MessageBoxA(hWnd, &Name, "Device Setup", 0x30u);
    result = 0;
  }
  else
  {
    dwIndex = 0;
    while ( 1 )
    {
      cchName = 80;
      if ( RegEnumKeyExA(hKey, dwIndex, (LPSTR)&Name, &cchName, 0, 0, 0, &ftLastWriteTime) )
        break;
      if ( Name != 68 || v36 != 101 )
      {
        ++dwIndex;
      }
      else
      {
        Data = 0;
        v3 = atoi(&Str);
        if ( !sub_10002590(v3, "DeviceName", &Data, 0x32u) )
        {
          MessageBoxA(hWnd, &Name, "Device Setup", 0x30u);
          RegCloseKey(hKey);
          return 1;
        }
        sprintf((char *)&Name, " %03d : {", v3);
        v4 = &Data;
        v5 = -1;
        do
        {
          if ( !v5 )
            break;
          v6 = *v4++ == 0;
          --v5;
        }
        while ( !v6 );
        v7 = ~v5;
        v8 = &v4[-v7];
        v9 = &Name;
        v10 = v7;
        v11 = -1;
        do
        {
          if ( !v11 )
            break;
          v6 = *v9++ == 0;
          --v11;
        }
        while ( !v6 );
        memcpy((void *)(v9 - 1), v8, v10);
        v12 = (int)"}";
        v13 = -1;
        do
        {
          if ( !v13 )
            break;
          v6 = *(_BYTE *)v12++ == 0;
          --v13;
        }
        while ( !v6 );
        v14 = ~v13;
        v15 = (const void *)(v12 - v14);
        v16 = &Name;
        v17 = v14;
        v18 = -1;
        do
        {
          if ( !v18 )
            break;
          v6 = *v16++ == 0;
          --v18;
        }
        while ( !v6 );
        v19 = (void *)(v16 - 1);
        memcpy(v19, v15, 4 * (v17 >> 2));
        v20 = v25;
        memcpy((char *)v19 + 4 * (v17 >> 2), (char *)v15 + 4 * (v17 >> 2), v17 & 3);
        lParam = v20;
        ++dwIndex;
        v31 = &Name;
        v32 = lstrlenA(&Name);
        v33 = v3;
        v21 = SendMessageA(v1, 0x1100u, 0, (LPARAM)&lParam);
        v26 = v21;
        if ( v3 == Value )
        {
          strcpy(dword_1000E544, &Name);
          SendMessageA(v1, 0x110Bu, 9u, v21);
          v21 = v26;
        }
        if ( dword_1000EA38 )
          sub_10002AE0(v1, v21, v3);
      }
    }
    RegCloseKey(hKey);
    SendMessageA(v1, 0x1102u, 2u, v25);
    v22 = SendMessageA(v1, 0x110Au, 9u, 0);
    SendMessageA(v1, 0x110Bu, 9u, v22);
    SetFocus(v1);
    result = 1;
  }
  return result;
}
// 1000EA38: using guessed type int dword_1000EA38;

//----- (10002AE0) --------------------------------------------------------
signed int __cdecl sub_10002AE0(HWND hWnd, LPARAM a2, unsigned __int32 Value)
{
  int v3; // edi@1
  signed int v4; // ecx@1
  bool v5; // zf@3
  signed int v6; // ecx@4
  const void *v7; // esi@4
  unsigned int v8; // ebp@4
  const CHAR *v9; // edi@4
  signed int v10; // ecx@4
  int *v11; // edi@7
  signed int v12; // ecx@7
  signed int v13; // ecx@10
  const void *v14; // esi@10
  unsigned int v15; // ebp@10
  const CHAR *v16; // edi@10
  signed int v17; // ecx@10
  signed int result; // eax@14
  int v19; // ebp@19
  int *v20; // edi@20
  signed int v21; // ecx@20
  signed int v22; // ecx@23
  const void *v23; // esi@23
  const CHAR *v24; // edi@23
  unsigned int v25; // edx@23
  signed int v26; // ecx@23
  int v27; // edi@26
  signed int v28; // ecx@26
  signed int v29; // ecx@29
  const void *v30; // esi@29
  const CHAR *v31; // edi@29
  unsigned int v32; // edx@29
  signed int v33; // ecx@29
  void *v34; // edi@32
  LPARAM v35; // edi@32
  HKEY v36; // [sp-4h] [bp-110h]@35
  DWORD dwIndex; // [sp+10h] [bp-FCh]@15
  HKEY hKey; // [sp+14h] [bp-F8h]@13
  DWORD cchName; // [sp+18h] [bp-F4h]@16
  LPARAM lParam; // [sp+1Ch] [bp-F0h]@32
  int v41; // [sp+20h] [bp-ECh]@1
  int v42; // [sp+24h] [bp-E8h]@1
  const CHAR *v43; // [sp+34h] [bp-D8h]@32
  int v44; // [sp+38h] [bp-D4h]@32
  unsigned __int32 v45; // [sp+48h] [bp-C4h]@32
  struct _FILETIME ftLastWriteTime; // [sp+50h] [bp-BCh]@16
  BYTE Data[52]; // [sp+58h] [bp-B4h]@1
  const CHAR Name; // [sp+8Ch] [bp-80h]@1
  char v49; // [sp+8Dh] [bp-7Fh]@18
  char Str; // [sp+92h] [bp-7Ah]@19
  char v51; // [sp+B4h] [bp-58h]@1

  v41 = -65534;
  v42 = 5;
  sub_10002320(Value, 3u, Data);
  memcpy((void *)&Name, "SYSTEM\\CurrentControlSet\\Services\\ADSDAQ", 0x28u);
  v51 = SubKey[40];
  v3 = (int)"\\Device";
  v4 = -1;
  do
  {
    if ( !v4 )
      break;
    v5 = *(_BYTE *)v3++ == 0;
    --v4;
  }
  while ( !v5 );
  v6 = ~v4;
  v7 = (const void *)(v3 - v6);
  v8 = v6;
  v9 = &Name;
  v10 = -1;
  do
  {
    if ( !v10 )
      break;
    v5 = *v9++ == 0;
    --v10;
  }
  while ( !v5 );
  memcpy((void *)(v9 - 1), v7, v8);
  v11 = (int *)Data;
  v12 = -1;
  do
  {
    if ( !v12 )
      break;
    v5 = *(_BYTE *)v11 == 0;
    v11 = (int *)((char *)v11 + 1);
    --v12;
  }
  while ( !v5 );
  v13 = ~v12;
  v14 = (char *)v11 - v13;
  v15 = v13;
  v16 = &Name;
  v17 = -1;
  do
  {
    if ( !v17 )
      break;
    v5 = *v16++ == 0;
    --v17;
  }
  while ( !v5 );
  memcpy((void *)(v16 - 1), v14, v15);
  if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE, &Name, 0, 0x20019u, &hKey) )
  {
    MessageBoxA(hWnd, &Name, "Device Setup", 0x30u);
    result = 0;
  }
  else
  {
    dwIndex = 0;
    while ( 1 )
    {
      cchName = 80;
      if ( RegEnumKeyExA(hKey, dwIndex, (LPSTR)&Name, &cchName, 0, 0, 0, &ftLastWriteTime) )
        break;
      if ( Name != 77 || v49 != 111 )
      {
        ++dwIndex;
      }
      else
      {
        Data[0] = 0;
        v19 = atoi(&Str);
        if ( !sub_100026A0(Value, v19, "DeviceName", Data, 0x32u) )
        {
          MessageBoxA(hWnd, &Name, "Device Setup", 0x30u);
          v36 = hKey;
          goto LABEL_37;
        }
        sprintf((char *)&Name, " %03d : <", v19);
        v20 = (int *)Data;
        v21 = -1;
        do
        {
          if ( !v21 )
            break;
          v5 = *(_BYTE *)v20 == 0;
          v20 = (int *)((char *)v20 + 1);
          --v21;
        }
        while ( !v5 );
        v22 = ~v21;
        v23 = (char *)v20 - v22;
        v24 = &Name;
        v25 = v22;
        v26 = -1;
        do
        {
          if ( !v26 )
            break;
          v5 = *v24++ == 0;
          --v26;
        }
        while ( !v5 );
        memcpy((void *)(v24 - 1), v23, v25);
        v27 = (int)">";
        v28 = -1;
        do
        {
          if ( !v28 )
            break;
          v5 = *(_BYTE *)v27++ == 0;
          --v28;
        }
        while ( !v5 );
        v29 = ~v28;
        v30 = (const void *)(v27 - v29);
        v31 = &Name;
        v32 = v29;
        v33 = -1;
        do
        {
          if ( !v33 )
            break;
          v5 = *v31++ == 0;
          --v33;
        }
        while ( !v5 );
        v34 = (void *)(v31 - 1);
        memcpy(v34, v30, 4 * (v32 >> 2));
        lParam = a2;
        memcpy((char *)v34 + 4 * (v32 >> 2), (char *)v30 + 4 * (v32 >> 2), v32 & 3);
        ++dwIndex;
        v43 = &Name;
        v44 = lstrlenA(&Name);
        v45 = Value + 200 * (5 * v19 + 5000);
        v35 = SendMessageA(hWnd, 0x1100u, 0, (LPARAM)&lParam);
        if ( Value + 1000 * v19 == ::Value )
        {
          ::Value = Value + 200 * (5 * v19 + 5000);
          sprintf(dword_1000E544, " %03d%03d : <%s>", v19, Value, Data);
          SendMessageA(hWnd, 0x1102u, 2u, a2);
          SendMessageA(hWnd, 0x110Bu, 9u, v35);
        }
      }
    }
    v36 = hKey;
LABEL_37:
    RegCloseKey(v36);
    result = 1;
  }
  return result;
}

//----- (100044A6) --------------------------------------------------------
char __cdecl sub_100044A6(int a1)
{
  HMODULE v1; // eax@1
  int v2; // ecx@2

  *(_DWORD *)a1 = 0;
  v1 = GetModuleHandleA(0);
  if ( *(_WORD *)v1 == 23117 )
  {
    v2 = *((_DWORD *)v1 + 15);
    if ( v2 )
    {
      v1 = (char *)v1 + v2;
      *(_BYTE *)a1 = *((_BYTE *)v1 + 26);
      LOBYTE(v1) = *((_BYTE *)v1 + 27);
      *(_BYTE *)(a1 + 1) = (_BYTE)v1;
    }
  }
  return (char)v1;
}

//----- (100044D3) --------------------------------------------------------
__int32 __cdecl sub_100044D3()
{
  __int32 result; // eax@4
  CHAR *v1; // ecx@6
  CHAR v2; // al@7
  char *v3; // eax@12
  CHAR *v4; // ecx@13
  CHAR v5; // al@14
  char *v6; // eax@20
  const char *v7; // eax@21
  const char *v8; // ecx@21
  CHAR Str2; // [sp+4h] [bp-122Ch]@5
  CHAR SubStr; // [sp+1094h] [bp-19Ch]@13
  struct _OSVERSIONINFOA VersionInformation; // [sp+1198h] [bp-98h]@1
  unsigned __int8 v12; // [sp+122Ch] [bp-4h]@29

  VersionInformation.dwOSVersionInfoSize = 148;
  if ( GetVersionExA(&VersionInformation)
    && VersionInformation.dwPlatformId == 2
    && VersionInformation.dwMajorVersion >= 5 )
  {
    result = 1;
  }
  else
  {
    if ( !GetEnvironmentVariableA("__MSVCRT_HEAP_SELECT", &Str2, 0x1090u) )
      goto LABEL_32;
    v1 = &Str2;
    if ( Str2 )
    {
      do
      {
        v2 = *v1;
        if ( *v1 >= 97 && v2 <= 122 )
          *v1 = v2 - 32;
        ++v1;
      }
      while ( *v1 );
    }
    if ( strncmp("__GLOBAL_HEAP_SELECTED", &Str2, 0x16u) )
    {
      GetModuleFileNameA(0, &SubStr, 0x104u);
      v4 = &SubStr;
      if ( SubStr )
      {
        do
        {
          v5 = *v4;
          if ( *v4 >= 97 && v5 <= 122 )
            *v4 = v5 - 32;
          ++v4;
        }
        while ( *v4 );
      }
      v3 = strstr(&Str2, &SubStr);
    }
    else
    {
      v3 = &Str2;
    }
    if ( !v3 || (v6 = strchr(v3, 44)) == 0 )
      goto LABEL_32;
    v7 = v6 + 1;
    v8 = v7;
    while ( *v8 )
    {
      if ( *v8 == 59 )
        *v8 = 0;
      else
        ++v8;
    }
    result = strtol(v7, 0, 10);
    if ( result != 2 )
    {
      if ( result != 3 && result != 1 )
      {
LABEL_32:
        sub_100044A6((int)&v12);
        result = 3 - (v12 < 6u);
      }
    }
  }
  return result;
}

//----- (1000461B) --------------------------------------------------------
signed int __cdecl sub_1000461B(int a1)
{
  __int32 v1; // eax@2
  LPVOID v2; // eax@3

  hHeap = HeapCreate(a1 == 0, 0x1000u, 0);
  if ( !hHeap )
    return 0;
  v1 = sub_100044D3();
  dword_1000FCA8 = v1;
  if ( v1 == 3 )
  {
    v2 = (LPVOID)__sbh_heap_init(1016);
  }
  else
  {
    if ( v1 != 2 )
      return 1;
    v2 = sub_100068B0();
  }
  if ( !v2 )
  {
    HeapDestroy(hHeap);
    return 0;
  }
  return 1;
}
// 1000605F: using guessed type _DWORD __cdecl __sbh_heap_init(_DWORD);
// 1000FCA8: using guessed type int dword_1000FCA8;

//----- (10004678) --------------------------------------------------------
BOOL __cdecl sub_10004678()
{
  int v0; // ebx@2
  char *v1; // esi@3
  void **v2; // esi@7
  void *v3; // eax@8

  if ( dword_1000FCA8 == 3 )
  {
    v0 = 0;
    if ( dword_1000EA58 > 0 )
    {
      v1 = (char *)lpMem + 12;
      do
      {
        VirtualFree(*(LPVOID *)v1, 0x100000u, 0x4000u);
        VirtualFree(*(LPVOID *)v1, 0, 0x8000u);
        HeapFree(hHeap, 0, *((LPVOID *)v1 + 1));
        v1 += 20;
        ++v0;
      }
      while ( v0 < dword_1000EA58 );
    }
    HeapFree(hHeap, 0, lpMem);
  }
  else
  {
    if ( dword_1000FCA8 == 2 )
    {
      v2 = &off_1000BCF0;
      do
      {
        v3 = v2[4];
        if ( v3 )
          VirtualFree(v3, 0, 0x8000u);
        v2 = (void **)*v2;
      }
      while ( v2 != &off_1000BCF0 );
    }
  }
  return HeapDestroy(hHeap);
}
// 1000BCF0: using guessed type void *off_1000BCF0;
// 1000EA58: using guessed type int dword_1000EA58;
// 1000FCA8: using guessed type int dword_1000FCA8;

//----- (10004CCC) --------------------------------------------------------
void __cdecl sub_10004CCC(signed int a1, int a2)
{
  if ( a1 >= 20 )
    EnterCriticalSection((LPCRITICAL_SECTION)(a2 + 32));
  else
    _lock(a1 + 28);
}
// 1000506B: using guessed type _DWORD __cdecl _lock(_DWORD);

//----- (10004D1E) --------------------------------------------------------
void __cdecl sub_10004D1E(signed int a1, int a2)
{
  if ( a1 >= 20 )
    LeaveCriticalSection((LPCRITICAL_SECTION)(a2 + 32));
  else
    _unlock(a1 + 28);
}
// 100050CC: using guessed type _DWORD __cdecl _unlock(_DWORD);

//----- (100050E1) --------------------------------------------------------
void *__cdecl sub_100050E1(int a1, int a2)
{
  int v2; // esi@1
  int v3; // ebx@2
  void *result; // eax@20
  size_t v5; // [sp-18h] [bp-38h]@10
  void *Dst; // [sp+0h] [bp-20h]@6
  int v7; // [sp+4h] [bp-1Ch]@1

  v2 = a2 * a1;
  v7 = a2 * a1;
  if ( (unsigned int)(a2 * a1) > 0xFFFFFFE0 )
  {
    v3 = 0;
  }
  else
  {
    v3 = 0;
    if ( !v2 )
      v2 = 1;
    v2 = (v2 + 15) & 0xFFFFFFF0;
  }
  while ( 1 )
  {
    Dst = (void *)v3;
    if ( (unsigned int)v2 <= 0xFFFFFFE0 )
    {
      if ( dword_1000FCA8 == 3 )
      {
        if ( v7 > (unsigned int)dword_1000EA60 )
          goto LABEL_16;
        _lock(9);
        Dst = (void *)__sbh_alloc_block(v7);
        sub_1000517A();
        if ( Dst != (void *)v3 )
        {
          v5 = a2 * a1;
LABEL_15:
          memset(Dst, v3, v5);
          goto LABEL_16;
        }
      }
      else
      {
        if ( dword_1000FCA8 != 2 || v2 > (unsigned int)dword_1000DD14 )
        {
LABEL_16:
          if ( Dst != (void *)v3 )
            return Dst;
          goto LABEL_17;
        }
        _lock(9);
        Dst = (void *)sub_10006BA8((unsigned int)v2 >> 4);
        sub_10005203();
        if ( Dst != (void *)v3 )
        {
          v5 = v2;
          goto LABEL_15;
        }
      }
LABEL_17:
      Dst = HeapAlloc(hHeap, 8u, v2);
    }
    if ( Dst != (void *)v3 || dword_1000E3FC == v3 )
      return Dst;
    result = (void *)_callnewh(v2);
    if ( !result )
      return result;
  }
}
// 1000506B: using guessed type _DWORD __cdecl _lock(_DWORD);
// 100063FB: using guessed type _DWORD __cdecl __sbh_alloc_block(_DWORD);
// 10007618: using guessed type _DWORD __cdecl _callnewh(_DWORD);
// 1000DD14: using guessed type int dword_1000DD14;
// 1000E3FC: using guessed type int dword_1000E3FC;
// 1000EA60: using guessed type int dword_1000EA60;
// 1000FCA8: using guessed type int dword_1000FCA8;

//----- (10005175) --------------------------------------------------------
void __cdecl sub_10005175()
{
  JUMPOUT(*(int *)sub_1000517A);
}

//----- (1000517A) --------------------------------------------------------
int __cdecl sub_1000517A()
{
  return _unlock(9);
}
// 100050CC: using guessed type _DWORD __cdecl _unlock(_DWORD);

//----- (100051FE) --------------------------------------------------------
void __cdecl sub_100051FE()
{
  JUMPOUT(*(int *)sub_10005203);
}

//----- (10005203) --------------------------------------------------------
int __cdecl sub_10005203()
{
  return _unlock(9);
}
// 100050CC: using guessed type _DWORD __cdecl _unlock(_DWORD);

//----- (1000521E) --------------------------------------------------------
int __usercall sub_1000521E<eax>(int result<eax>, unsigned int a2)
{
  unsigned int v2; // eax@3
  bool v3; // zf@5
  int v4; // eax@7
  void *v5; // [sp-10h] [bp-38h]@11
  int v6; // [sp+0h] [bp-28h]@7
  int v7; // [sp+4h] [bp-24h]@7
  int v8; // [sp+8h] [bp-20h]@7
  unsigned int v9; // [sp+Ch] [bp-1Ch]@3
  int v10; // [sp+18h] [bp-10h]@1
  int (__cdecl *v11)(int, PVOID, int); // [sp+1Ch] [bp-Ch]@1
  _UNKNOWN *v12; // [sp+20h] [bp-8h]@1
  int v13; // [sp+24h] [bp-4h]@1

  v13 = -1;
  v12 = &unk_100094F8;
  v11 = unknown_libname_1;
  v10 = result;
  if ( a2 )
  {
    if ( dword_1000FCA8 == 3 )
    {
      _lock(9);
      v13 = 0;
      v2 = __sbh_find_block(a2);
      v9 = v2;
      if ( v2 )
        sub_100060D2(v2, a2);
      v13 = -1;
      result = sub_10005288();
      v3 = v9 == 0;
    }
    else
    {
      if ( dword_1000FCA8 != 2 )
      {
        v5 = (void *)a2;
        return HeapFree(hHeap, 0, v5);
      }
      _lock(9);
      v13 = 1;
      v4 = sub_10006B0C(a2, (int)&v6, (int)&v8);
      v7 = v4;
      if ( v4 )
        sub_10006B63(v6, v8, v4);
      v13 = -1;
      result = sub_100052E0();
      v3 = v7 == 0;
    }
    if ( !v3 )
      return result;
    v5 = (void *)a2;
    return HeapFree(hHeap, 0, v5);
  }
  return result;
}
// 1000506B: using guessed type _DWORD __cdecl _lock(_DWORD);
// 100060A7: using guessed type _DWORD __cdecl __sbh_find_block(_DWORD);
// 1000FCA8: using guessed type int dword_1000FCA8;

//----- (10005288) --------------------------------------------------------
int __cdecl sub_10005288()
{
  return _unlock(9);
}
// 100050CC: using guessed type _DWORD __cdecl _unlock(_DWORD);

//----- (100052E0) --------------------------------------------------------
int __cdecl sub_100052E0()
{
  return _unlock(9);
}
// 100050CC: using guessed type _DWORD __cdecl _unlock(_DWORD);

//----- (10005345) --------------------------------------------------------
LPVOID __cdecl sub_10005345(unsigned int a1)
{
  void *v1; // ST18_4@3
  LPVOID result; // eax@3
  int v3; // esi@7
  int v4; // ST18_4@10
  signed int v5; // eax@12
  int v6; // eax@14
  SIZE_T v7; // [sp-10h] [bp-2Ch]@11

  if ( dword_1000FCA8 == 3 )
  {
    if ( a1 <= dword_1000EA60 )
    {
      _lock(9);
      v1 = (void *)__sbh_alloc_block(a1);
      sub_100053AC();
      result = v1;
      if ( v1 )
        return result;
    }
    goto LABEL_12;
  }
  if ( dword_1000FCA8 != 2 )
  {
LABEL_12:
    v5 = a1;
    if ( !a1 )
      v5 = 1;
    v6 = v5 + 15;
    LOBYTE(v6) = v6 & 0xF0;
    v7 = v6;
    goto LABEL_15;
  }
  if ( a1 )
    v3 = (a1 + 15) & 0xFFFFFFF0;
  else
    v3 = 16;
  if ( v3 > (unsigned int)dword_1000DD14
    || (_lock(9), v4 = sub_10006BA8((unsigned int)v3 >> 4), sub_1000540B(), (result = (LPVOID)v4) == 0) )
  {
    v7 = v3;
LABEL_15:
    result = HeapAlloc(hHeap, 0, v7);
  }
  return result;
}
// 1000506B: using guessed type _DWORD __cdecl _lock(_DWORD);
// 100063FB: using guessed type _DWORD __cdecl __sbh_alloc_block(_DWORD);
// 1000DD14: using guessed type int dword_1000DD14;
// 1000EA60: using guessed type int dword_1000EA60;
// 1000FCA8: using guessed type int dword_1000FCA8;

//----- (100053AC) --------------------------------------------------------
int __cdecl sub_100053AC()
{
  return _unlock(9);
}
// 100050CC: using guessed type _DWORD __cdecl _unlock(_DWORD);

//----- (1000540B) --------------------------------------------------------
int __cdecl sub_1000540B()
{
  return _unlock(9);
}
// 100050CC: using guessed type _DWORD __cdecl _unlock(_DWORD);

//----- (100060D2) --------------------------------------------------------
unsigned int __cdecl sub_100060D2(unsigned int a1, int a2)
{
  unsigned int result; // eax@1
  int v3; // esi@1
  unsigned int v4; // edi@1
  signed int v5; // ecx@1
  int v6; // ebx@2
  int v7; // edx@3
  int v8; // ecx@7
  unsigned int v9; // ebx@7
  bool v10; // zf@7
  int v11; // ecx@9
  unsigned int v12; // ebx@9
  int v13; // ecx@11
  int v14; // edx@14
  int v15; // ebx@17
  unsigned int v16; // esi@24
  unsigned int v17; // esi@26
  int v18; // ecx@33
  void *v19; // eax@43
  unsigned int v20; // [sp+Ch] [bp-10h]@1
  signed int v21; // [sp+10h] [bp-Ch]@2
  signed int v22; // [sp+14h] [bp-8h]@2
  int v23; // [sp+18h] [bp-4h]@1
  int v24; // [sp+28h] [bp+Ch]@2
  int v25; // [sp+28h] [bp+Ch]@17
  char v26; // [sp+2Bh] [bp+Fh]@34

  result = *(_DWORD *)(a1 + 16);
  v3 = a2 - 4;
  v4 = (unsigned int)(a2 - *(_DWORD *)(a1 + 12)) >> 15;
  v20 = 516 * ((unsigned int)(a2 - *(_DWORD *)(a1 + 12)) >> 15) + result + 324;
  v5 = *(_DWORD *)(a2 - 4) - 1;
  v23 = *(_DWORD *)(a2 - 4) - 1;
  if ( !(v5 & 1) )
  {
    v6 = v5 + v3;
    v21 = *(_DWORD *)(v5 + v3);
    v22 = *(_DWORD *)(a2 - 8);
    v24 = v5 + v3;
    if ( !(v21 & 1) )
    {
      v7 = (v21 >> 4) - 1;
      if ( (unsigned int)v7 > 0x3F )
        v7 = 63;
      if ( *(_DWORD *)(v6 + 4) == *(_DWORD *)(v6 + 8) )
      {
        if ( (unsigned int)v7 >= 0x20 )
        {
          v11 = v7 + result + 4;
          v12 = ~(0x80000000u >> (v7 - 32));
          *(_DWORD *)(result + 4 * v4 + 196) &= v12;
          v10 = (*(_BYTE *)v11)-- == 1;
          if ( v10 )
            *(_DWORD *)(a1 + 4) &= v12;
        }
        else
        {
          v8 = v7 + result + 4;
          v9 = ~(0x80000000u >> v7);
          *(_DWORD *)(result + 4 * v4 + 68) &= v9;
          v10 = (*(_BYTE *)v8)-- == 1;
          if ( v10 )
            *(_DWORD *)a1 &= v9;
        }
        v13 = v23;
        v6 = v24;
      }
      else
      {
        v13 = v23;
      }
      v5 = v21 + v13;
      *(_DWORD *)(*(_DWORD *)(v6 + 8) + 4) = *(_DWORD *)(v6 + 4);
      v23 = v5;
      *(_DWORD *)(*(_DWORD *)(v24 + 4) + 8) = *(_DWORD *)(v24 + 8);
    }
    v14 = (v5 >> 4) - 1;
    if ( (unsigned int)v14 > 0x3F )
      v14 = 63;
    if ( v22 & 1 )
    {
      v15 = a1;
    }
    else
    {
      v25 = v3 - v22;
      v15 = (v22 >> 4) - 1;
      if ( (unsigned int)v15 > 0x3F )
        v15 = 63;
      v23 = v22 + v5;
      v14 = ((v22 + v5) >> 4) - 1;
      if ( (unsigned int)v14 > 0x3F )
        v14 = 63;
      if ( v15 != v14 )
      {
        if ( *(_DWORD *)(v25 + 4) == *(_DWORD *)(v25 + 8) )
        {
          if ( (unsigned int)v15 >= 0x20 )
          {
            v17 = ~(0x80000000u >> (v15 - 32));
            *(_DWORD *)(result + 4 * v4 + 196) &= v17;
            v10 = (*(_BYTE *)(v15 + result + 4))-- == 1;
            if ( v10 )
              *(_DWORD *)(a1 + 4) &= v17;
          }
          else
          {
            v16 = ~(0x80000000u >> v15);
            *(_DWORD *)(result + 4 * v4 + 68) &= v16;
            v10 = (*(_BYTE *)(v15 + result + 4))-- == 1;
            if ( v10 )
              *(_DWORD *)a1 &= v16;
          }
        }
        *(_DWORD *)(*(_DWORD *)(v25 + 8) + 4) = *(_DWORD *)(v25 + 4);
        *(_DWORD *)(*(_DWORD *)(v25 + 4) + 8) = *(_DWORD *)(v25 + 8);
      }
      v3 = v25;
    }
    if ( v22 & 1 || v15 != v14 )
    {
      v18 = v20 + 8 * v14;
      *(_DWORD *)(v3 + 4) = *(_DWORD *)(v20 + 8 * v14 + 4);
      *(_DWORD *)(v3 + 8) = v18;
      *(_DWORD *)(v18 + 4) = v3;
      *(_DWORD *)(*(_DWORD *)(v3 + 4) + 8) = v3;
      if ( *(_DWORD *)(v3 + 4) == *(_DWORD *)(v3 + 8) )
      {
        v26 = *(_BYTE *)(v14 + result + 4);
        *(_BYTE *)(v14 + result + 4) = v26 + 1;
        if ( (unsigned int)v14 >= 0x20 )
        {
          if ( !v26 )
            *(_DWORD *)(a1 + 4) |= 0x80000000u >> (v14 - 32);
          *(_DWORD *)(result + 4 * v4 + 196) |= 0x80000000u >> (v14 - 32);
        }
        else
        {
          if ( !v26 )
            *(_DWORD *)a1 |= 0x80000000u >> v14;
          *(_DWORD *)(result + 4 * v4 + 68) |= 0x80000000u >> v14;
        }
      }
    }
    *(_DWORD *)v3 = v23;
    *(_DWORD *)(v23 + v3 - 4) = v23;
    result = v20;
    v10 = *(_DWORD *)v20 == 1;
    --*(_DWORD *)result;
    if ( v10 )
    {
      if ( Dst )
      {
        VirtualFree((LPVOID)(*((_DWORD *)Dst + 3) + (dword_1000EA4C << 15)), 0x8000u, 0x4000u);
        *((_DWORD *)Dst + 2) |= 0x80000000u >> dword_1000EA4C;
        *(_DWORD *)(*((_DWORD *)Dst + 4) + 4 * dword_1000EA4C + 196) = 0;
        --*(_BYTE *)(*((_DWORD *)Dst + 4) + 67);
        v19 = Dst;
        if ( !*(_BYTE *)(*((_DWORD *)Dst + 4) + 67) )
        {
          *((_DWORD *)Dst + 1) &= 0xFFFFFFFEu;
          v19 = Dst;
        }
        if ( *((_DWORD *)v19 + 2) == -1 )
        {
          VirtualFree(*((LPVOID *)v19 + 3), 0, 0x8000u);
          HeapFree(hHeap, 0, *((LPVOID *)Dst + 4));
          memcpy_0(Dst, (char *)Dst + 20, (size_t)((char *)lpMem + 20 * dword_1000EA58-- - (_DWORD)Dst - 20));
          if ( a1 > (unsigned int)Dst )
            a1 -= 20;
          dword_1000EA50 = (int)lpMem;
        }
      }
      result = a1;
      dword_1000EA4C = v4;
      Dst = (void *)a1;
    }
  }
  return result;
}
// 1000EA4C: using guessed type int dword_1000EA4C;
// 1000EA50: using guessed type int dword_1000EA50;
// 1000EA58: using guessed type int dword_1000EA58;

//----- (100068B0) --------------------------------------------------------
LPVOID __cdecl sub_100068B0()
{
  LPVOID v0; // esi@2
  void *v1; // eax@4
  unsigned int v2; // edi@4
  int v3; // eax@12
  signed int v4; // ebp@12
  int v5; // edx@13

  if ( dword_1000BD00 == -1 )
  {
    v0 = &off_1000BCF0;
  }
  else
  {
    v0 = HeapAlloc(hHeap, 0, 0x2020u);
    if ( !v0 )
      return 0;
  }
  v1 = VirtualAlloc(0, 0x400000u, 0x2000u, 4u);
  v2 = (unsigned int)v1;
  if ( !v1 )
  {
LABEL_19:
    if ( v0 != &off_1000BCF0 )
      HeapFree(hHeap, 0, v0);
    return 0;
  }
  if ( !VirtualAlloc(v1, 0x10000u, 0x1000u, 4u) )
  {
    VirtualFree((LPVOID)v2, 0, 0x8000u);
    goto LABEL_19;
  }
  if ( v0 == &off_1000BCF0 )
  {
    if ( !off_1000BCF0 )
      off_1000BCF0 = &off_1000BCF0;
    if ( !off_1000BCF4 )
      off_1000BCF4 = &off_1000BCF0;
  }
  else
  {
    *(_DWORD *)v0 = &off_1000BCF0;
    *((_DWORD *)v0 + 1) = off_1000BCF4;
    off_1000BCF4 = v0;
    **((_DWORD **)v0 + 1) = v0;
  }
  *((_DWORD *)v0 + 5) = v2 + 4194304;
  v3 = (int)((char *)v0 + 24);
  *((_DWORD *)v0 + 3) = (char *)v0 + 152;
  *((_DWORD *)v0 + 4) = v2;
  *((_DWORD *)v0 + 2) = (char *)v0 + 24;
  v4 = 0;
  do
  {
    v5 = v4++ >= 16;
    *(_DWORD *)v3 = ((v5 - 1) & 0xF1) - 1;
    *(_DWORD *)(v3 + 4) = 241;
    v3 += 8;
  }
  while ( v4 < 1024 );
  memset((void *)v2, 0, 0x10000u);
  while ( v2 < *((_DWORD *)v0 + 4) + 65536 )
  {
    *(_BYTE *)(v2 + 248) = -1;
    *(_DWORD *)v2 = v2 + 8;
    *(_DWORD *)(v2 + 4) = 240;
    v2 += 4096;
  }
  return v0;
}
// 1000BCF0: using guessed type void *off_1000BCF0;
// 1000BD00: using guessed type int dword_1000BD00;

//----- (100069F4) --------------------------------------------------------
BOOL __cdecl sub_100069F4(void **lpMem)
{
  BOOL result; // eax@1

  result = VirtualFree(lpMem[4], 0, 0x8000u);
  if ( off_1000DD10 == lpMem )
  {
    result = (BOOL)lpMem[1];
    off_1000DD10 = (void **)lpMem[1];
  }
  if ( lpMem == &off_1000BCF0 )
  {
    dword_1000BD00 = -1;
  }
  else
  {
    *(_DWORD *)lpMem[1] = *lpMem;
    *((_DWORD *)*lpMem + 1) = lpMem[1];
    result = HeapFree(hHeap, 0, lpMem);
  }
  return result;
}
// 1000BCF0: using guessed type void *off_1000BCF0;
// 1000BD00: using guessed type int dword_1000BD00;
// 1000DD10: using guessed type void **off_1000DD10;

//----- (10006A4A) --------------------------------------------------------
void __cdecl sub_10006A4A(int a1)
{
  LPVOID v1; // esi@1
  int v2; // edi@3
  signed int v3; // ebx@3
  unsigned int v4; // eax@6
  LPVOID v5; // ecx@11
  int v6; // eax@13
  signed int v7; // edx@13
  int v8; // [sp+Ch] [bp-4h]@3

  v1 = off_1000BCF4;
  do
  {
    if ( *((_DWORD *)v1 + 4) != -1 )
    {
      v8 = 0;
      v2 = (int)((char *)v1 + 8208);
      v3 = 4190208;
      do
      {
        if ( *(_DWORD *)v2 == 240 && VirtualFree((LPVOID)(*((_DWORD *)v1 + 4) + v3), 0x1000u, 0x4000u) )
        {
          *(_DWORD *)v2 = -1;
          --dword_1000E3BC;
          v4 = *((_DWORD *)v1 + 3);
          if ( !v4 || v4 > v2 )
            *((_DWORD *)v1 + 3) = v2;
          ++v8;
          --a1;
          if ( !a1 )
            break;
        }
        v3 -= 4096;
        v2 -= 8;
      }
      while ( v3 >= 0 );
      v5 = v1;
      v1 = (LPVOID)*((_DWORD *)v1 + 1);
      if ( v8 && *((_DWORD *)v5 + 6) == -1 )
      {
        v6 = (int)((char *)v5 + 32);
        v7 = 1;
        do
        {
          if ( *(_DWORD *)v6 != -1 )
            break;
          ++v7;
          v6 += 8;
        }
        while ( v7 < 1024 );
        if ( v7 == 1024 )
          sub_100069F4((void **)v5);
      }
    }
  }
  while ( v1 != off_1000BCF4 && a1 > 0 );
}
// 1000E3BC: using guessed type int dword_1000E3BC;

//----- (10006B0C) --------------------------------------------------------
int __cdecl sub_10006B0C(unsigned int a1, int a2, int a3)
{
  void **v3; // ecx@1

  v3 = &off_1000BCF0;
  while ( a1 <= (unsigned int)v3[4] || a1 >= (unsigned int)v3[5] )
  {
    v3 = (void **)*v3;
    if ( v3 == &off_1000BCF0 )
      return 0;
  }
  if ( !(a1 & 0xF) && (a1 & 0xFFF) >= 0x100 )
  {
    *(_DWORD *)a2 = v3;
    *(_DWORD *)a3 = a1 & 0xF000;
    return ((signed int)(a1 - (unsigned __int16)(a1 & 0xF000) - 256) >> 4) + (unsigned __int16)(a1 & 0xF000) + 8;
  }
  return 0;
}
// 1000BCF0: using guessed type void *off_1000BCF0;

//----- (10006B63) --------------------------------------------------------
void __cdecl sub_10006B63(int a1, int a2, int a3)
{
  int v3; // eax@1
  bool v4; // zf@1

  v3 = a1 + 8 * ((a2 - *(_DWORD *)(a1 + 16)) >> 12) + 24;
  *(_DWORD *)v3 += *(_BYTE *)a3;
  *(_BYTE *)a3 = 0;
  v4 = *(_DWORD *)v3 == 240;
  *(_DWORD *)(v3 + 4) = 241;
  if ( v4 )
  {
    ++dword_1000E3BC;
    if ( dword_1000E3BC == 32 )
      sub_10006A4A(16);
  }
}
// 1000E3BC: using guessed type int dword_1000E3BC;

//----- (10006BA8) --------------------------------------------------------
int __cdecl sub_10006BA8(unsigned int a1)
{
  void **v1; // esi@1
  void *v2; // edx@2
  int v3; // edi@3
  int v4; // eax@3
  unsigned int v5; // ebx@4
  int result; // eax@6
  void **v7; // edi@22
  void *v8; // ebx@27
  void *v9; // eax@27
  int i; // esi@27
  unsigned int v11; // ecx@31
  int v12; // eax@32
  int v13; // eax@34
  bool v14; // cf@35
  LPVOID v15; // eax@40
  int v16; // ecx@41
  unsigned int Val; // [sp+Ch] [bp-8h]@11
  int v18; // [sp+10h] [bp-4h]@3
  int v19; // [sp+10h] [bp-4h]@11
  signed int v20; // [sp+10h] [bp-4h]@27

  v1 = off_1000DD10;
  do
  {
    v2 = v1[4];
    if ( v2 == (void *)-1 )
    {
      v5 = a1;
    }
    else
    {
      v3 = (int)v1[2];
      v4 = (int)((char *)v2 + 4096 * ((signed int)(v1[2] - v1 - 24) >> 3));
      v18 = (int)((char *)v2 + 4096 * ((signed int)(v1[2] - v1 - 24) >> 3));
      if ( v3 < (unsigned int)(v1 + 2054) )
      {
        while ( 1 )
        {
          v5 = a1;
          if ( *(_DWORD *)v3 >= (signed int)a1 && *(_DWORD *)(v3 + 4) > a1 )
          {
            result = sub_10006DB0(v4, *(_DWORD *)v3, a1);
            if ( result )
            {
LABEL_21:
              off_1000DD10 = v1;
              *(_DWORD *)v3 -= v5;
              v1[2] = (void *)v3;
              return result;
            }
            v4 = v18;
            *(_DWORD *)(v3 + 4) = a1;
          }
          v3 += 8;
          v4 += 4096;
          v18 = v4;
          if ( v3 >= (unsigned int)(v1 + 2054) )
            goto LABEL_11;
        }
      }
      v5 = a1;
LABEL_11:
      v3 = (int)(v1 + 6);
      Val = (unsigned int)v1[2];
      v19 = (int)v1[4];
      if ( (unsigned int)(v1 + 6) < Val )
      {
        do
        {
          if ( *(_DWORD *)v3 >= (signed int)v5 && *(_DWORD *)(v3 + 4) > v5 )
          {
            result = sub_10006DB0(v19, *(_DWORD *)v3, v5);
            if ( result )
              goto LABEL_21;
            *(_DWORD *)(v3 + 4) = v5;
          }
          v19 += 4096;
          v3 += 8;
        }
        while ( v3 < Val );
      }
    }
    v1 = (void **)*v1;
  }
  while ( v1 != off_1000DD10 );
  v7 = &off_1000BCF0;
  while ( v7[4] == (void *)-1 || !v7[3] )
  {
    v7 = (void **)*v7;
    if ( v7 == &off_1000BCF0 )
    {
      v15 = sub_100068B0();
      if ( v15 )
      {
        v16 = *((_DWORD *)v15 + 4);
        *(_BYTE *)(v16 + 8) = v5;
        off_1000DD10 = (void **)v15;
        *(_DWORD *)v16 = v16 + v5 + 8;
        *(_DWORD *)(v16 + 4) = 240 - v5;
        *((_DWORD *)v15 + 6) -= (unsigned __int8)v5;
        return v16 + 256;
      }
      return 0;
    }
  }
  v8 = v7[3];
  v20 = 0;
  v9 = v8;
  for ( i = (int)((char *)v7[4] + 4096 * ((signed int)(v8 - v7 - 24) >> 3)); *(_DWORD *)v9 == -1; ++v20 )
  {
    if ( v20 >= 16 )
      break;
    v9 = (char *)v9 + 8;
  }
  if ( VirtualAlloc((LPVOID)i, v20 << 12, 0x1000u, 4u) != (LPVOID)i )
    return 0;
  memset((void *)i, v20 << 12, 0);
  v11 = (unsigned int)v8;
  if ( v20 > 0 )
  {
    v12 = i + 4;
    do
    {
      *(_BYTE *)(v12 + 244) = -1;
      *(_DWORD *)(v12 - 4) = v12 + 4;
      *(_DWORD *)v12 = 240;
      *(_DWORD *)v11 = 240;
      *(_DWORD *)(v11 + 4) = 241;
      v12 += 4096;
      v11 += 8;
      --v20;
    }
    while ( v20 );
  }
  off_1000DD10 = v7;
  v13 = (int)(v7 + 2054);
  while ( 1 )
  {
    v14 = v11 < v13;
    if ( v11 >= v13 )
      break;
    if ( *(_DWORD *)v11 == -1 )
    {
      v14 = v11 < v13;
      break;
    }
    v11 += 8;
  }
  v7[3] = (void *)(v14 ? v11 : 0);
  *(_BYTE *)(i + 8) = a1;
  v7[2] = v8;
  *(_DWORD *)v8 -= a1;
  *(_DWORD *)(i + 4) -= a1;
  result = i + 256;
  *(_DWORD *)i = i + a1 + 8;
  return result;
}
// 1000BCF0: using guessed type void *off_1000BCF0;
// 1000DD10: using guessed type void **off_1000DD10;

//----- (10006DB0) --------------------------------------------------------
int __cdecl sub_10006DB0(int a1, unsigned int a2, unsigned int a3)
{
  int v3; // ecx@1
  unsigned int v4; // esi@1
  unsigned int v5; // edi@1
  int v6; // ebx@1
  int v7; // eax@1
  int v8; // eax@5
  int v9; // esi@6
  int v10; // ebx@10
  signed int v11; // esi@10
  int v12; // esi@20
  int v13; // ebx@24
  signed int v14; // eax@24
  unsigned int v16; // [sp+Ch] [bp-4h]@1
  int v17; // [sp+18h] [bp+8h]@1

  v3 = a1;
  v4 = *(_DWORD *)(a1 + 4);
  v5 = *(_DWORD *)a1;
  v6 = a1 + 248;
  v16 = *(_DWORD *)a1;
  v7 = *(_DWORD *)a1;
  v17 = a1 + 248;
  if ( v4 >= a3 )
  {
    *(_BYTE *)v5 = a3;
    if ( v5 + a3 >= v6 )
    {
      *(_DWORD *)(v3 + 4) = 0;
      *(_DWORD *)v3 = v3 + 8;
    }
    else
    {
      *(_DWORD *)v3 += a3;
      *(_DWORD *)(v3 + 4) -= a3;
    }
    v8 = v5 + 8;
    return 16 * v8 - 15 * v3;
  }
  v9 = v5 + v4;
  if ( *(_BYTE *)v9 )
    v7 = v9;
  if ( v7 + a3 >= v6 )
  {
LABEL_20:
    v12 = v3 + 8;
    while ( v12 < v5 && v12 + a3 < v17 )
    {
      if ( *(_BYTE *)v12 )
      {
        v12 += *(_BYTE *)v12;
      }
      else
      {
        v13 = v12 + 1;
        v14 = 1;
        while ( !*(_BYTE *)v13 )
        {
          ++v13;
          ++v14;
        }
        if ( v14 >= a3 )
        {
          if ( v12 + a3 >= v17 )
          {
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)v3 = v3 + 8;
          }
          else
          {
            *(_DWORD *)v3 = v12 + a3;
            *(_DWORD *)(v3 + 4) = v14 - a3;
          }
          *(_BYTE *)v12 = a3;
          v8 = v12 + 8;
          return 16 * v8 - 15 * v3;
        }
        a2 -= v14;
        if ( a2 < a3 )
          return 0;
        v12 = v13;
      }
    }
    return 0;
  }
  while ( *(_BYTE *)v7 )
  {
    v7 += *(_BYTE *)v7;
LABEL_19:
    if ( v7 + a3 >= v17 )
      goto LABEL_20;
  }
  v10 = v7 + 1;
  v11 = 1;
  while ( !*(_BYTE *)v10 )
  {
    ++v10;
    ++v11;
  }
  if ( v11 < a3 )
  {
    if ( v7 == v16 )
    {
      *(_DWORD *)(v3 + 4) = v11;
    }
    else
    {
      a2 -= v11;
      if ( a2 < a3 )
        return 0;
    }
    v5 = v16;
    v7 = v10;
    goto LABEL_19;
  }
  if ( v7 + a3 >= v17 )
  {
    *(_DWORD *)(v3 + 4) = 0;
    *(_DWORD *)v3 = v3 + 8;
  }
  else
  {
    *(_DWORD *)v3 = v7 + a3;
    *(_DWORD *)(v3 + 4) = v11 - a3;
  }
  *(_BYTE *)v7 = a3;
  v8 = v7 + 8;
  return 16 * v8 - 15 * v3;
}

//----- (10007330) --------------------------------------------------------
int __cdecl sub_10007330()
{
  return flsall(1);
}
// 10007339: using guessed type _DWORD __cdecl flsall(_DWORD);

// ALL OK, 70 function(s) have been successfully decompiled
